<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>My Note</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<div id="header">
<h1 class="title">My Note</h1>
</div>
<p>Java &#20195;&#30721; &amp; C/C++ &#20195;&#30721;&#65292;&#26080;&#35821;&#35328;&#20195;&#30721;&#65288;&#36825;&#19981;&#26159; note&#65292;&#20294;&#24212;&#24403;&#25910;&#24405;&#22312; fulltext &#37324;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">byte</span>    b   =   <span class="dv">3</span>;
<span class="dt">int</span>     i   =   b;

<span class="dt">double</span>  y   =   <span class="fl">2.7</span>;
<span class="dt">int</span>     x   =   (<span class="dt">int</span>)y;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span> (okay) {
    printf(<span class="st">&quot;Hello World</span><span class="ch">\n</span><span class="st">&quot;</span>);
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="kw">if</span> (okay) {
    cout &lt;&lt; <span class="st">&quot;Hello World&quot;</span> &lt;&lt; endl;
}</code></pre></div>
<pre><code>http://127.0.0.1:1080/pac?t=20161203153117736</code></pre>
<p><code class="sourceCode cpp">print hello is your name.</code></p>
<ul>
<li><dl>
<dt><a href="https://www.douban.com/people/sting999/status/1918804013/">sting &#30340;&#24191;&#25773;&#65306;&#21338;&#22763;&#21518;</a></dt>
<dd><p>&#29616;&#22312;&#22269;&#20869;&#39640;&#26657;&#37117;&#22312;&#22823;&#32902;&#25193;&#24352;&#21338;&#22763;&#21518;&#25110;&#32773;&#8220;&#24072;&#36164;&#8221;&#21338;&#22763;&#21518;&#65292;&#25104;&#30334;&#19978;&#21315;&#30340;&#25307;&#21338;&#22763;&#21518;&#65292;&#23454;&#38469;&#19978;&#26159;&#21464;&#30456;&#30340;&#23558;&#38738;&#24180;&#21338;&#22763;&#22900;&#24037;&#21270;&#30340;&#26041;&#24335;&#65292;&#33021;&#22815;&#20570;&#23436;&#21338;&#22763;&#21518;&#30041;&#19979;&#25104;&#20026;&#27491;&#24335;&#25945;&#24072;&#30340;&#20154;&#25968;&#38750;&#24120;&#30340;&#23569;&#65292;&#32780;&#19988;&#36234;&#26469;&#36234;&#23569;&#12290;&#21482;&#35201;&#25171;&#21548;&#19968;&#19979;&#35813;&#26657;&#30340;&#25945;&#24072;&#32534;&#21046;&#21644;&#27491;&#22312;&#25307;&#30340;&#21338;&#22763;&#21518;&#20154;&#25968;&#30340;&#27604;&#20363;&#23601;&#19981;&#38590;&#30475;&#20986;&#26469;&#12290;&#21363;&#23558;&#25214;&#24037;&#20316;&#30340;&#21516;&#23398;&#20204;&#24910;&#20043;&#12290;</p>
<p>&#29616;&#21338;&#22763;&#27605;&#19994;&#25214;&#21040;&#22266;&#23450;&#32844;&#20301;&#30830;&#23454;&#38750;&#24120;&#38590;&#20102;&#65292;&#26377;&#23398;&#26657;&#24191;&#25746;&#32593;&#25307;&#25910;&#21338;&#21518;&#65288;&#22914;&#24191;&#19996;&#26576;&#26657;&#65289;&#65292;&#26377;&#20123;&#23398;&#26657;&#24191;&#25746;&#32593;&#25307;&#19987;&#32844;&#31185;&#30740;&#23703;&#65288;&#22914;&#21335;&#20140;&#26576;&#26657;&#65289;&#65292;&#24448;&#24448;&#32473;&#30340;&#24453;&#36935;&#30830;&#23454;&#24456;&#39640;&#65292;&#20294;&#26159;&#22522;&#26412;&#22823;&#37096;&#20998;&#37117;&#24456;&#38590;&#30041;&#19979;&#65292;&#19968;&#25343;&#21040;&#38754;&#19978;&#22522;&#37329;&#30340;&#24072;&#22992;&#20063;&#24551;&#24515;&#24545;&#24545;&#25285;&#24515;&#33021;&#19981;&#33021;&#30041;&#19979;&#65292;&#22522;&#26412;&#19978;&#21338;&#22763;&#37117;&#34987;&#24403;&#35770;&#25991;&#29399;&#26469;&#20351;&#29992;&#65292;&#22909;&#22810;&#20154;&#21338;&#21518;&#21518;&#32773;&#19987;&#32844;&#30041;&#19981;&#19979;&#65292;&#28982;&#21518;&#24754;&#20652;&#20154;&#29983;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#32593;&#32476;&#35774;&#32622;</dt>
<dd><p>url: <code class="sourceCode html">ms-settings:network-proxy</code></p>
<dl>
<dt>500 Internal Privoxy Error</dt>
<dd><p>Privoxy encountered an error while processing your request:</p>
<p>Could not load template file no-server-data or one of its included components.</p>
<p>Please contact your proxy administrator.</p>
<p>If you are the proxy administrator, please put the required file(s)in the (confdir)/templates directory. The location of the (confdir) directory is specified in the main Privoxy config file. (It&#8217;s typically the Privoxy install directory).</p>
</dd>
</dl>
</dd>
</dl></li>
<li><a href="https://www.zhihu.com/question/36505902">&#22914;&#20309;&#35780;&#20215;&#38899;&#20048;&#21095;&#12298;&#27721;&#23494;&#23572;&#39039;&#12299;(Hamilton)&#65311; - &#30693;&#20046;</a></li>
</ul>
<div class="sourceCode" id="mycode1" startFrom="100"><table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>100
101
102
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell">qsort []     <span class="fu">=</span> []
qsort (x<span class="fu">:</span>xs) <span class="fu">=</span> qsort (filter (<span class="fu">&lt;</span> x) xs) <span class="fu">++</span> [x] <span class="fu">++</span>
               qsort (filter (<span class="fu">&gt;=</span> x) xs)</code></pre></td></tr></table></div>
<div class="sourceCode" id="mycode2"><pre class="sourceCode haskell haskell"><code class="sourceCode haskell">qsort []     <span class="fu">=</span> []
qsort (x<span class="fu">:</span>xs) <span class="fu">=</span> qsort (filter (<span class="fu">&lt;</span> x) xs) <span class="fu">++</span> [x] <span class="fu">++</span>
               qsort (filter (<span class="fu">&gt;=</span> x) xs)</code></pre></div>
<ul>
<li><dl>
<dt>ambiguity: declaration or multiplication? -&lt;</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Class::X *p;
<span class="co">// X can be object of Class, or a nested class.</span>
<span class="co">// so ambi&#39;guity occurs</span>
Type::NestedType   * p;         <span class="co">// declare</span>
Type::object * p;               <span class="co">// multiplication</span></code></pre></div>
<p>&#36890;&#24120;&#22312;&#29992; template &#30340;&#26102;&#20505;&#21487;&#33021;&#32534;&#35793;&#22120;&#26080;&#27861;&#30693;&#36947;&#21040;&#24213;&#26159;&#20309;&#31181;&#24773;&#20917;&#65292;&#21487;&#20197;&#21152;&#19978; <code>typename</code> &#21363;&#29992; <code>typename Type::NestedType *p</code>&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>2d-vector is esier to use -&lt;</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// c</span>
<span class="dt">int</span> **ary = <span class="kw">new</span> <span class="dt">int</span>*[row_num];
<span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; row_num; ++i) {
    ary[i] = <span class="kw">new</span> <span class="dt">int</span>[col_num];
    <span class="co">// delete[] ary[i];</span>
}
<span class="co">// delete[] ary;</span>

<span class="co">// cpp</span>
vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; ary(row_num, vector&lt;<span class="dt">int</span>&gt;(col_num, <span class="dv">0</span>));</code></pre></div>
<p>make sure to clear it&#8217;s contents when necessary.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vec.clear();                <span class="co">// the performance depends on how&#39;s your dtor</span>

<span class="co">// or</span>
vector&lt;T&gt;().swap( x );      <span class="co">// clear x reallocating</span></code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://www.cplusplus.com/reference/vector/vector/clear/">vector::clear - C++ Reference</a></li>
<li><a href="http://stackoverflow.com/questions/16420357/c-fastest-way-to-clear-or-erase-a-vector">performance - C++ fastest way to clear or erase a vector - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20351;&#29992; reserve &#26469;&#36991;&#20813;&#19981;&#24517;&#35201;&#30340;&#37325;&#26032;&#20998;&#37197; -&lt;</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// void std::vector::reserve( size_type new_cap );</span>
vector&lt;<span class="dt">int</span>&gt; nums;
nums.reserve( <span class="dv">25</span> );</code></pre></div>
<p>&#20294;&#19981;&#35201;&#20197;&#20026; <code>size()</code> &#20063;&#21464;&#20102;&#12290;&#20320;&#21487;&#20197;&#29992; <code>resize( int num )</code>&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/container/vector/reserve">std::vector::reserve - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>tolower, toupper, isalpha -&lt;</dt>
<dd><p>defined in <code>&lt;ctype.h&gt;</code> or <code>&lt;cctype&gt;</code> (<code>std::tolower</code>).</p>
<p><strong>tolower, touppper</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;ctype.h&gt;</span>

<span class="dt">int</span> toupper( <span class="dt">int</span> c );
<span class="dt">int</span> tolower( <span class="dt">int</span> c );</code></pre></div>
<p>converts the letter c to upper/lower case, if possible.</p>
<p>if not ASCII, or EOF, the behavior is undefined.</p>
<p><strong>isalpha, isspace, isdigit, isalnum, isxdigit</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> isalnum(    <span class="dt">int</span> c   );
<span class="dt">int</span> isalpha(    <span class="dt">int</span> c   );
<span class="dt">int</span> isascii(    <span class="dt">int</span> c   );
<span class="dt">int</span> isblank(    <span class="dt">int</span> c   );
<span class="dt">int</span> iscntrl(    <span class="dt">int</span> c   );
<span class="dt">int</span> isdigit(    <span class="dt">int</span> c   );
<span class="dt">int</span> isgraph(    <span class="dt">int</span> c   );
<span class="dt">int</span> isprint(    <span class="dt">int</span> c   );
<span class="dt">int</span> ispunct(    <span class="dt">int</span> c   );
<span class="dt">int</span> isspace(    <span class="dt">int</span> c   );
<span class="dt">int</span> isxdigit(   <span class="dt">int</span> c   );</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>even <em>vs</em> odd&#65292;&#22855;&#20598;&#25968;&#21028;&#26029; -&lt;</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// even</span>
x % <span class="dv">2</span>
<span class="co">// odd</span>
x % <span class="dv">2</span> != <span class="dv">0</span>
x &amp; <span class="bn">0x1</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>equal? float/double &#25968;&#30340;&#21028;&#31561; -&lt;</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// for int</span>
a == b
<span class="co">// for double</span>
fabs(a-b) &lt; <span class="fl">1e-9</span>        <span class="co">// math.h</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#25991;&#20214;&#35835;&#20889;&#65292;&#29992; FILE&#65292;fscanf &#25110;&#32773; ifstream&#65292;getline -&lt;</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

FILE *fp = fopen(filename, <span class="st">&quot;r&quot;</span>);
<span class="kw">while</span>( <span class="dv">2</span> == fscanf( fp, <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%s</span><span class="st">&quot;</span>, &amp;index, buf ) ) {
    <span class="co">// ...</span>
}
fclose(fp);

size_t fread(        <span class="dt">void</span> *ptr, size_t size, size_t nmemb, FILE *stream );
size_t fwrite( <span class="dt">const</span> <span class="dt">void</span> *ptr, size_t size, size_t nmemb, FILE *stream );</code></pre></div>
<p>&#34429;&#28982;&#20320;&#21487;&#33021;&#21916;&#27426; <code>fopen</code>&#65288;&#23601;&#36319;&#25105;&#20197;&#21069;&#19968;&#26679;&#65289;&#65292;&#20294;&#25105;&#25512;&#33616;&#29992; C++ &#30340; stream&#65292;&#22240;&#20026;&#23427;&#26356;&#23433;&#20840;&#65288;&#19981;&#26159;&#25351;&#38024;&#65292;&#27809;&#26377;&#27844;&#38706;&#21361;&#38505;&#65289;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;fstream&gt;</span>

std::ifstream file( filename.c_str(), ifstream::in );
<span class="co">// &#25110;&#32773;&#65306;std::ifstream file; file.open( filename.c_str(), ifstream::in );</span>

<span class="kw">if</span> ( !file ) { exit(<span class="dv">-1</span>); }
<span class="co">// &#25110;&#32773;&#65306;if ( !file.is_open() ) { exit(-1); }</span>

string line;
<span class="kw">while</span> ( getline(file, line) ) {
    <span class="co">// ...</span>
}</code></pre></div>
<p>&#36825;&#20010; <code>if( !file )</code> &#26159;&#22240;&#20026; file &#37325;&#36733;&#20102; <code>operator void *</code>&#65292;&#36825;&#21477;&#35805;&#31561;&#21516;&#20110; <code>if( NULL == (void *)file )</code>&#65292;&#35265; <a href="http://program.upc.edu.cn/CLibrary/iostream/ios/operator_voidpt.html">ios::operator void* - C++ Reference</a>&#12290;</p>
<dl>
<dt><a href="http://www.artima.com/cppsource/safebool.html">The Safe Bool Idiom</a> -&lt;</dt>
<dd><p><strong>Learn how to validate objects in a boolean context without the usual harmful side effects.</strong></p>
<dl>
<dt>The Goal -&lt;</dt>
<dd><p>Test their validity in Boolean contexts</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// method 1</span>
<span class="kw">if</span> (some_type* p=get_some_type()) {
    <span class="co">// p is valid, use it</span>
}
<span class="kw">else</span> {
    <span class="co">// p is not valid, take proper action</span>
}

<span class="co">// method 2</span>
smart_ptr&lt;some_type&gt; p(get_some_type());
<span class="kw">if</span> (p.is_valid()) {
    <span class="co">// p is valid, use it</span>
}
<span class="kw">else</span> {
    <span class="co">// p is not valid, take proper action</span>
}</code></pre></div>
</dd>
<dt>The Obvious Approach Is <code>operator bool</code>, and also, the Not Exactly Obvious, <code>operator!</code> -&lt;</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// operator bool version</span>
<span class="kw">class</span> Testable {
    <span class="dt">bool</span> ok_;
<span class="kw">public</span>:
    <span class="kw">explicit</span> Testable(<span class="dt">bool</span> b=<span class="kw">true</span>):ok_(b) {}

    <span class="kw">operator</span> <span class="dt">bool</span>() <span class="dt">const</span> {
        <span class="kw">return</span> ok_;
    }
    <span class="dt">bool</span> <span class="kw">operator</span>!() <span class="dt">const</span> {
        <span class="kw">return</span> !ok_;
    }
};</code></pre></div>
</dd>
<dt>A Seemingly Innocent Approach: <code>operator void *</code> -&lt;</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">operator</span> <span class="dt">void</span>*() <span class="dt">const</span> {
    <span class="kw">return</span> ok_==<span class="kw">true</span> ? <span class="kw">this</span> : <span class="dv">0</span>;
}</code></pre></div>
<p>good? see this:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Testable test;

<span class="co">// oops...</span>
<span class="kw">delete</span> test;</code></pre></div>
<p>If you think that this situation can be saved with a little const trickery, think again: The C++ Standard explicitly allows delete expressions with pointers to const types.</p>
</dd>
<dt>Almost Getting There with a Nested Class -&lt;</dt>
<dd><p>In 1996, Don Box wrote about a very clever technique in his C++ Report column a technique originally created to support testing for nullness that almost does what we came here for. It involves a conversion function to a nested type (that doesn&#8217;t even need to be defined), like so:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Testable {
    <span class="dt">bool</span> ok_;
<span class="kw">public</span>:
    <span class="kw">explicit</span> Testable(<span class="dt">bool</span> b=<span class="kw">true</span>):ok_(b) {}
    <span class="kw">class</span> nested_class;         <span class="co">// no need to implement;</span>
    <span class="kw">operator</span> <span class="dt">const</span> nested_class*() <span class="dt">const</span> {
      <span class="kw">return</span> ok_ ? <span class="kw">reinterpret_cast</span>&lt;<span class="dt">const</span> nested_class*&gt;(<span class="kw">this</span>) : <span class="dv">0</span>;
    }
};</code></pre></div>
</dd>
<dt>The Safe Bool Idiom -&lt;</dt>
<dd><p>It&#8217;s time to make these tests safe. Remember that we need to avoid unsafe conversions that allow for erroneous usage. We must also avoid overloading issues, and we definitely shouldn&#8217;t allow deletion through the conversion. So, what do we do? Without further ado, let me give you the solution in code.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Testable {
    <span class="dt">bool</span> ok_;
    <span class="kw">typedef</span> <span class="dt">void</span> (Testable::*bool_type)() <span class="dt">const</span>;
    <span class="dt">void</span> this_type_does_not_support_comparisons() <span class="dt">const</span> {}
<span class="kw">public</span>:
    <span class="kw">explicit</span> Testable(<span class="dt">bool</span> b=<span class="kw">true</span>):ok_(b) {}
    <span class="kw">operator</span> bool_type() <span class="dt">const</span> {
        <span class="kw">return</span> ok_==<span class="kw">true</span> ?  &amp;Testable::this_type_does_not_support_comparisons : <span class="dv">0</span>;
    }
};</code></pre></div>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/6242768/is-the-safe-bool-idiom-obsolete-in-c11">c++ - Is the safe-bool idiom obsolete in C++11? - Stack Overflow</a></li>
</ul>
</dd>
</dl>
</dd>
</dl></li>
</ul>
<p><code>shitshitshit</code></p>
<pre><code>shitshitshitshitshitshit</code></pre>
</body>
</html>
